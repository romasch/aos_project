\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}


% For the \todo{} command.
\usepackage{todo}

% Nice fonts
\usepackage{palatino}
% Needed for Listings package with Eiffel.
% \usepackage{xcolor}
% Source code listings.
\usepackage{listings}
% Appendix with extra title.
% \usepackage [page] {appendix}
% To include PNG files.
% \usepackage{graphicx}
% Nice looking captions.
\usepackage[font={footnotesize,sl}, labelfont=bf] {caption}
% Include PDF pages.
% \usepackage{pdfpages}

% Clickable links. Has to be the last package:
\usepackage [hidelinks] {hyperref}


\lstset{language=C,basicstyle=\ttfamily\small}


\newcommand{\todoref}{\todo{ref}}
\newcommand{\filepath}[1]{\emph{ #1}}

% Title Page
\title{Advanced Operating Systems \\ Project Report}
\author{Roman Schmocker \\ Yauhen Klimiankou}


\begin{document}

\maketitle


\section{Introduction}

This report provides documentation for the operating system which we built as part of the project in the Advanced Operating Systems course.
The code is based on a stripped-down version of Barrelfish \cite {web:barrelfish}.

\todo{ more introduction}

\section{Getting started}

\begin{lstlisting}

void test_listings_package (void);

void test_listings_package (void)
{
  uint32_t an_int;
  char* a_string = "asdf";
  for (int i=0; i<42; i++) {
    printf (a_string);
  }
}
\end{lstlisting}


\section {Modules}

\subsection{Paging}

The paging code is mostly contained in \filepath{lib/barrelfish/paging.c} and the corresponding header file.

The central element is the \lstinline!paging_state! struct.
When desgining the data structure for the paging code we had these use cases in mind:

\begin{itemize}
 \item Fast lookup if an address is valid.
 \item Fast lookup of the page tables associated to the virtual address.
 \item Fast allocation of new frames.
 \item Quick unmap operations when the memory server asks us to return a frame.
\end{itemize}

To support the first use case we just keep track of the allocated range of virtual addresses using two integer variables.
That way determining if a page fault is ``valid'' is very simple: 
If it's in the range, everything's ok and we can map a new frame, if not we abort the process due to an invalid address.

The data structure of choice to represent the page table structure is a two-level array that mirrors the actual page tables in memory.
Currently we only store the capability to the page tables and whether a certain page has been allocated at some point.
We don't yet store any flags, pointers to a swap file or other metadata, but it would be easy to add this information.

Frame management is a bit more complex because we always allocate frames of 1 MiB.
That way we can avoid an IPC call for every single page fault, but we also have to keep track of free and allocated space within a frame.
The \lstinline!struct frame_list! manages this information for a single frame.
To support the last use case it also keeps track of the actual pages backed by this frame.

The \lstinline!paging_state! struct then maintains a double ended queue of \lstinline!frame_list! nodes, where only the frame at the head of the list may contain some free space.

As already mentioned, an important use case we had in mind were unmap requests from the memory server.
We never implemented that functionality, but the data structure is designed to support it.
An implementation would have to do the following:
\begin{itemize}
 \item Remove the last \lstinline!frame_list! element.
 \item Write all pages backed by this frame to disk.
 \item (Optionally) update some flags and metadata in the page table array.
 \item Return the frame to the memory server.
\end{itemize}

\todo{Advantages and disadvantages}

This has the disadvantage that we don't support returning \textbf{virtual} address space, but at that time we didn't think that this would be needed, 
especially because the malloc/free implementation never returns any memory to morecore as well.



% 
% - Intent: quick lookup of page table, ``unmap'' requests from memory server
% 
% - Data structues
% -- Simple for virtual memory
% -- 2-level array for page tables (mirroring actual page tables)
% -- linked list for frames
% 
% - Problem: No unmap from domain itself
% -- esp. no recycling of virtual addresses
% -- we thought that malloc would never return memory anyway
% -- didn't think about domain spawning / bulk transfer with explicit map/unmap operations

\subsection{Communication / Local Message Passing}

- Synchronous message passing, one-to-one
- channels between any client/server possible (not just init)
- general format: service identifier, args -> reply: error code, args
- aos\_rpc.c: client API
-- support feature \lstinline!aos_send_receive!
-- only initialize arguments and receive result.
- aos\_support/server.c: generic server support routines
- routing: in init - service registration, find requests
- bulk transfer: shared buffer, bound to a channel
- predefined channels (provided by libbarrelfish): init, serial\_driver

\subsection{Shell and serial I/O}
- Implemented in memeater.c
- serial driver in own domain
- \lstinline!set_foreground! for input selection
-- disadvantage: not very safe...
- big if-elseif construct to parse commands...
- \lstinline!aos_rpc_send_string! to send a large string to serial driver, but currently not used

\subsection{Process management}
- currently done in init
- server manages process table and info about loaded modules
-- can be printed with ps command
- shell attempts to start program with specific name if command not recognized
- mechanism to register for end notification (foreground tasks)
- kill command to revoke dispatcher capability (background tasks)
- no further cleanup for zombie domains as for now

\subsection{Mupltiple Cores}

\todo {}

\subsection{FAT file system}
- filesystem code in aos\_support/fat32.c
- handler in mmchs/filesystem\_server.c
- Currently read-only
- some support for partition tables
- Performance improvements: sequential read? cached FAT? bulk transfer?

\subsubsection{ ELF loading}

\todo {Implement ELF loading}

\section{Conclusion}

\begin{flushleft}
{{{
\bibliographystyle {plain}
\bibliography {./references}
}}}
\end{flushleft}


\todos

\end{document}          
 
